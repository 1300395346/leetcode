# 单调栈

## 引言

栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。

单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。

用简洁的话来说就是：单调栈就是`栈内元素单调递增或者单调递减`的栈，单调栈只能在**栈顶操作**。

听起来有点像`堆（heap）`？不是的，单调栈的用途不太广泛，只处理一种典型问题，叫做`Next Greater Element`。

## 介绍

首先，讲解`Next Greater Number`的原始问题：给你一个数组，返回一个等长的数组，对应索引存储着下一个更大的元素，如果没有更大的元素，就存-1。

输入`[2,1,2,4,3]`，输出`[4,2,4,-1,-1]`。

```java
class Solution {
    public int[] next(int[] Test) {
        Deque<Integer> stack = new ArrayDeque<>();
        int len = Test.length;
        int[] ans = new int[len];
        for (int i = len - 1; i >= 0; --i) {
            while (!stack.isEmpty() && stack.peek() <= Test[i]) {
                stack.pop();
            }
            ans[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(Test[i]);
        }
        return ans;
    }
}
```

这就是单调队列解决问题的模板。for循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈实际就是正着出栈。while循环是把两个“高个”之间的元素排除，因为他们的存在没有意义，前面挡着“更高”的元素，所以他们不可能被作为后续进来的元素的Next
Greater Number了。

这个算法的时间复杂度不是那么直观，如果你看到for循环嵌套while循环，可能认为这个算法的时间复杂度是O(n^2)，但是实际上这个算法的时间复杂度只有O(n)。

分析它的时间复杂度要从整体来看：总共有n个元素，每个元素都被push入栈一次，而最多会被pop一次，没有任何冗余操作。所以总的计算规模是和元素规模n成正比的，也就是O(n)的复杂度。

单调栈讲解完毕。下面开始另一个重点：如何处理[循环数组]。

同样是Next Greater Number，现在假设给你的数组是个环形的，如何处理？

输入`[2,1,2,4,3]`，输出`[4,2,4,-1,4]`。

实际上，计算机的内存都是线性的，是没有真正意义上的环形数组的，但是我们可以模拟出环形数组的效果，一般都是通过`%`运算符求模（余数），获得环形特效

```java
class Cycle {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int len = arr.length;
        int index = 0;
        while (true) {
            System.out.print(arr[index % len]);
            index++;
        }
    }
}
```

因此，在上述问题中，笨办法是将数组扩充成原来的两倍，答案在截取前一半，便得到了正确答案。实际上，还能够利用循环数组的技巧来进行模拟，代码如下：

```java
class Solution {
    public int[] Test(int[] nums) {
        int n = nums.length;
        int[] ans = new int[len];
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 2 * n - 1; i >= 0; --i) {
            while (!stack.isEmpty() && stack.peek() <= nums[i % n]) {
                stack.pop();
            }
            ans[i % n] = stack.isEmpty() ? -1 : stack.peek();
        }
        return ans;
    }
}
```

另外，单调栈也可以用于离线解决**RMQ问题**

我们可以把所有询问按右端点排序，然后每次在序列上从左往右扫描到当前询问的右端点处，并把扫描到的元素插入到单调栈中。这样，每次回答询问时，单调栈中存储的值都是位置≤r的、可能成为答案的决策点，并且这些元素满足单调性质。此时，单调栈上第一个位置≥l的元素就是当前询问的答案，这个过程可以用二分查找实现。使用单调栈解决RMQ问题的时间复杂度为O(
qlogq+qlogn)，空间复杂度为O(n)。

## 总结

单调栈实质上就是以某个值为最小（最大）值，向这个值的两侧延伸，遇到大于它（小于它）的值，就将它延伸的范围扩大。一般来说，要这样做的算法复杂度为O(n^2)。但借助栈这个数据结构，维护它的单调性，就可以在O(n)
的时间复杂度解决问题。（维护一个单调递增的单调栈）将一个元素加入栈时，先判断它是否大于栈顶元素，若是大于栈顶元素，则加入栈。否则，将栈顶元素弹出，直到栈顶元素小于要加入栈的元素。在此过程中，需要维护向前延伸或向后延伸的问题，当要加入栈的元素之前有n个元素出栈，那么说明这n个出栈的元素都会大于或等于要入栈的元素。
