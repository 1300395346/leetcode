# 常见子数组问题 通用解法

## 1.和积 最值问题

    第`i`位置的答案，一定由第`i-1`位置的答案发展而来，不用考虑`i-2`，`i-3`...

    因此用普通dp，可以做到O(n)

- 最大子数组和（[力扣](https://leetcode-cn.com/problems/maximum-subarray/)）：给你一个整数数组`nums`，请找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
  
  - 普通DP。因为它向前扩展比连上`dp[i-1]，考虑``dp[i-2]`的话就不是连续子数组了。
  
  - 有一个更优解法判断**sum**是否大于0的，其实就是化简后的普通DP。

- 乘积最大子数组（[力扣](https://leetcode-cn.com/problems/maximum-product-subarray/)）：给你一个整数数组`nums`，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数组），并返回该子数组所对应的乘积。
  
  - 可普通DP，同上。只不过是状态机DP。    

## 2.和积 定值问题

### 2.1 同向滑窗

    双指针，以右边界为循环中心，每次+1；不满足条件时左边界收缩。

    要求：**右指针右移 和 左指针右移 效果相反**。这样收缩左边界才可以抵消右边界带来的作用。

- 和大于等于`target`的最短子数组（[力扣](https://leetcode-cn.com/problems/2VG8Kg/)）：给定一个含有`n`个正整数的数组和一个整数`target`。找出该数组中满足和`≥target`的长队最小的**连续子数组**，并返回其长度。如果不存在符合条件的子数组，就返回`0`。
  
  - 建议：推荐 建立窗口 和 移动窗口 写在一个循环中。不推荐滑窗先写个循环建立窗口，再写个循环向右滑动。建立窗口循环末尾容易漏掉这种情况：窗口盛满序列时，还需要移动窗口左边缘以达到最优解。

### 2.2 前缀和+哈希

    前缀和数组，把子数组和问题转化为两数之差（类似 两数之和）问题。用哈希遍历缩减时间复杂度。

- 和为K的子数组（[力扣](https://leetcode-cn.com/problems/subarray-sum-equals-k/)）：给你一个整数数组`nums`和一个整数`k`，请你统计并返回*该数组中和为```k的子数组的个数*。
  
  - 这道题重点是整数数组，可能存在负数，因此不能使用滑窗。若数组中元素全部为正数，那么**右指针右移 和 左指针右移 效果相反**：前者使sum增加，后者使sum减小。

- 0和1个数相同的子数组
  
  - 这道题不能使用滑窗，理由与上题相同，即：**右指针右移 和 左指针右移 并不能保证效果相反**。右指针右移可能导致增加一个0；此时收缩窗口，左指针右移并不能保证减少一个0或增加一个1。

### 2.3 其他

DP问题有两种电信的问题：子数组和子序列。

- 求子数组时，一般是O(n)，因为我们求dp[i]时，只用考虑dp[i-1]。

- 求子序列时，一般是O(n^2)，我们需要考虑所有`dp[j](j<i)`。

关于前缀和与滑动窗口的一些解释。

前缀和：

- 用O(1)综合了前N个数的特征（有状态压缩的思想）。

- 虽然只是求和，我们不能像真正状态压缩一样保留前n个数的全部数据，相当于只保留了“和”这一部分特征。

- 但当问题与我们所保留的特征相符时，即可完美从O(N)转化为O(1)。那么，什么类型的问题能这么做呢？那就看上文即可明白，什么时候用同向滑窗，什么时候用前缀和 + 哈希。 这是就需要思考：追溯思路的起因。怎么做重要，怎么想到这么做更重要。

同向滑窗：

- 假设右边界为遍历的重心，每次扩大右边界时，检查条件，如果不符，左边界收缩。

- 右边界不同时，**左边界是连续收缩的**。这就是滑动窗口从O(N)转化为O(1)的核心。

- 同理，一些题目中用到反向滑窗（如快速排序，反向双指针比同向更容易理解，且不容易错）。能用反向滑窗的前提条件是：**左指针右移 和 右指针左移 效果相反**。并且反向滑窗能把O(N)降低为O(1)的核心也是：假设左边界看作循环的重心，那么右边界收缩是**连续的**，并不用每次都从nums.length-1出发向左一一检查。


